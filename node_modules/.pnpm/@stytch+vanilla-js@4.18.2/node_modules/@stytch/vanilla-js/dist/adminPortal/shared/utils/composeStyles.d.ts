import { Theme as DefaultTheme } from '@material-ui/core/styles/createTheme';
import { ClassNameMap, StyleRules, StyleRulesCallback } from '@material-ui/core/styles/withStyles';
type PartialStyles<Theme, ClassKey extends string, Props extends object> = ((theme: Theme) => Partial<StyleRules<ClassKey, Props>>) | Partial<StyleRules<ClassKey, Props>>;
export declare const composeStyles: <Theme = DefaultTheme, Props extends object = {}, ClassKey extends string = string>(...styles: PartialStyles<Theme, ClassKey, Props>[]) => StyleRulesCallback<Theme, Props, ClassKey>;
/**
 * A factory function for creating a makeStyles function with a base set of
 * styles. Use this when creating a shared version of a component that needs to
 * accept additional styles.
 *
 * @param baseStyles Base styles to be applied first
 * @returns A typed version of makeStyles that merges the given base style with
 * additional styles supplied later
 *
 * @example
 * ```tsx
 * const makeButtonStyles = makeStylesFactory((theme) => ({
 *   // base styles
 *   button: {
 *     padding: theme.spacing(1),
 *   },
 * }));
 *
 * // Base component definition
 * const ButtonCore = ({ classes, ...props }: ButtonProps & Classes<typeof makeButtonStyles>) => {
 *   // ...
 * };
 *
 * // Hook that generates merged styles
 * const useStyles = makeButtonStyles((theme) => ({
 *   // additional styles to be merged
 *   button: {
 *     backgroundColor: theme.palette.primary.main,
 *   },
 * }));
 *
 * // Customized component definition
 * const Button = (props: ButtonProps) => {
 *   const classes = useStyles();
 *   return <ButtonCore {...props} classes={classes} />;
 * };
 * ```
 */
export declare const makeStylesFactory: <Props extends object, ClassKey extends string>(...baseStyles: PartialStyles<DefaultTheme, ClassKey, Props>[]) => <TProps extends Props>(...styles: PartialStyles<DefaultTheme, ClassKey, TProps>[]) => keyof TProps extends never ? (props?: any) => ClassNameMap<ClassKey> : (props: TProps) => ClassNameMap<ClassKey>;
export type ClassKeyFromFactory<T> = T extends (...args: any) => (...args: any) => ClassNameMap<infer U> ? ClassNameMap<U> : never;
/**
 * A type that adds a `classes` prop to a component's props, given a factory
 * function returned from `makeStylesFactory`.
 *
 * @example
 * ```tsx
 * const MyComponent = ({ classes, ...props }: MyComponentProps & Classes<typeof makeMyComponentStyles>) => {
 *   // classes is the return value of `useStyles`
 * };
 * ```
 */
export type Classes<T> = {
    classes: ClassKeyFromFactory<T>;
};
export type WithClasses<P, T> = P & Classes<T>;
export {};
