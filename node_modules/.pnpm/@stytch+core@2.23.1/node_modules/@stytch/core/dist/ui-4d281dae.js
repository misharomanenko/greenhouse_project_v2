function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `oauth`, `otp`, `crypto` and `passwords`.
 */
var Products;
(function (Products) {
  Products["emailMagicLinks"] = "emailMagicLinks";
  Products["oauth"] = "oauth";
  Products["otp"] = "otp";
  Products["crypto"] = "crypto";
  Products["passwords"] = "passwords";
  Products["passkeys"] = "passkeys";
})(Products || (Products = {}));
/**
 * The OAuth providers we support in our OAuth product.
 * Currently we support `Amazon`, `Apple`, `Bitbucket`, `Discord`, `Facebook`, `Figma`, `Google`, `GitLab`,
 * `LinkedIn`, `Microsoft`, `Salesforce`, `Slack`, `Snapchat`, `TikTok`, `Twitch`, `Twitter`, and `Yahoo`.
 */
var OAuthProviders;
(function (OAuthProviders) {
  OAuthProviders["Google"] = "google";
  OAuthProviders["Microsoft"] = "microsoft";
  OAuthProviders["Apple"] = "apple";
  OAuthProviders["Github"] = "github";
  OAuthProviders["GitLab"] = "gitlab";
  OAuthProviders["Facebook"] = "facebook";
  OAuthProviders["Discord"] = "discord";
  OAuthProviders["Salesforce"] = "salesforce";
  OAuthProviders["Slack"] = "slack";
  OAuthProviders["Amazon"] = "amazon";
  OAuthProviders["Bitbucket"] = "bitbucket";
  OAuthProviders["LinkedIn"] = "linkedin";
  OAuthProviders["Coinbase"] = "coinbase";
  OAuthProviders["Twitch"] = "twitch";
  OAuthProviders["Twitter"] = "twitter";
  OAuthProviders["TikTok"] = "tiktok";
  OAuthProviders["Snapchat"] = "snapchat";
  OAuthProviders["Figma"] = "figma";
  OAuthProviders["Yahoo"] = "yahoo";
})(OAuthProviders || (OAuthProviders = {}));
/**
 * The Crypto Wallets we support in our crypto product.
 * Currently we support all ethereum and solana wallets.
 * We additionally detect and show popular wallets as distinct options.
 * The list of poular wallets include `Binance`, `Coinbase`, `Metamask`, `Phantom`, and `Vessel`
 */
var Wallets;
(function (Wallets) {
  Wallets["Vessel"] = "Vessel";
  Wallets["Phantom"] = "Phantom";
  Wallets["Metamask"] = "Metamask";
  Wallets["Coinbase"] = "Coinbase";
  Wallets["Binance"] = "Binance";
  Wallets["GenericEthereumWallet"] = "Other Ethereum Wallet";
  Wallets["GenericSolanaWallet"] = "Other Solana Wallet";
})(Wallets || (Wallets = {}));
/**
 * Supported behaviors for positioning Google One Tap. The actual behavior
 * depends on browser support and Google's One Tap implementation.
 */
var OneTapPositions;
(function (OneTapPositions) {
  /**
   * Display Google One Tap using a native browser prompt if available, or
   * embedded in the existing SDK login form otherwise.
   * @deprecated This option has been renamed to `floatingOrEmbedded`
   */
  OneTapPositions["embedded"] = "embedded";
  /**
   * Display the One Tap prompt using a native browser prompt if available, or
   * in the top right corner otherwise. This is the default option.
   */
  OneTapPositions["floating"] = "floating";
  /**
   * Display the One Tap prompt embedded in the existing SDK login form if a
   * native browser prompt is not available, or not at all otherwise. This
   * option is not recommended for new applications.
   */
  OneTapPositions["embeddedOnly"] = "embeddedOnly";
  /**
   * Display the One Tap prompt using a native browser prompt if available, or
   * embedded in the existing SDK login form otherwise.
   */
  OneTapPositions["floatingOrEmbedded"] = "floatingOrEmbedded";
  /**
   * Attempt to display the One Tap prompt embedded in the existing SDK login
   * form, even if a native browser prompt is supported. This option is not
   * recommended. It disables native browser FedCM support even where it is
   * available, and will stop being honored by Google in the future.
   */
  OneTapPositions["forceLegacyEmbedded"] = "forceLegacyEmbedded";
})(OneTapPositions || (OneTapPositions = {}));
/**
 * The methods array allows you to specify the authentication methods that you would like to expose
 * to your users. The order of the products that you include here will also be the order in which
 * they appear in the login form, with the first product specified appearing at the top of the login
 * form. We currently support passcodes on `email`, `sms` and `whatsapp`
 */
var OTPMethods;
(function (OTPMethods) {
  OTPMethods["SMS"] = "sms";
  OTPMethods["WhatsApp"] = "whatsapp";
  OTPMethods["Email"] = "email";
})(OTPMethods || (OTPMethods = {}));
var StytchEventType;
(function (StytchEventType) {
  StytchEventType["MagicLinkLoginOrCreateEvent"] = "MAGIC_LINK_LOGIN_OR_CREATE";
  StytchEventType["OTPsLoginOrCreateEvent"] = "OTP_LOGIN_OR_CREATE";
  StytchEventType["OTPsAuthenticate"] = "OTP_AUTHENTICATE";
  StytchEventType["CryptoWalletAuthenticateStart"] = "CRYPTO_WALLET_AUTHENTICATE_START";
  StytchEventType["CryptoWalletAuthenticate"] = "CRYPTO_WALLET_AUTHENTICATE";
  StytchEventType["PasswordCreate"] = "PASSWORD_CREATE";
  StytchEventType["PasswordAuthenticate"] = "PASSWORD_AUTHENTICATE";
  StytchEventType["PasswordResetByEmailStart"] = "PASSWORD_RESET_BY_EMAIL_START";
  StytchEventType["PasswordResetByEmail"] = "PASSWORD_RESET_BY_EMAIL";
  StytchEventType["PasskeyRegister"] = "PASSKEY_REGISTER";
  StytchEventType["PasskeyAuthenticate"] = "PASSKEY_AUTHENTICATE";
  StytchEventType["PasskeySkip"] = "PASSKEY_SKIP";
  StytchEventType["PasskeyDone"] = "PASSKEY_DONE";
  // More Events will go here ...
  // B2B Events
  StytchEventType["B2BMagicLinkEmailLoginOrSignup"] = "B2B_MAGIC_LINK_EMAIL_LOGIN_OR_SIGNUP";
  StytchEventType["B2BMagicLinkAuthenticate"] = "B2B_MAGIC_LINK_AUTHENTICATE";
  StytchEventType["B2BMagicLinkEmailDiscoverySend"] = "B2B_MAGIC_LINK_EMAIL_DISCOVERY_SEND";
  StytchEventType["B2BMagicLinkDiscoveryAuthenticate"] = "B2B_MAGIC_LINK_DISCOVERY_AUTHENTICATE";
  StytchEventType["B2BSSOStart"] = "B2B_SSO_START";
  StytchEventType["B2BSSOAuthenticate"] = "B2B_SSO_AUTHENTICATE";
  StytchEventType["B2BOAuthAuthenticate"] = "B2B_OAUTH_AUTHENTICATE";
  StytchEventType["B2BOAuthDiscoveryAuthenticate"] = "B2B_OAUTH_DISCOVERY_AUTHENTICATE";
  StytchEventType["B2BDiscoveryOrganizationsCreate"] = "B2B_DISCOVERY_ORGANIZATIONS_CREATE";
  StytchEventType["B2BDiscoveryIntermediateSessionExchange"] = "B2B_DISCOVERY_INTERMEDIATE_SESSION_EXCHANGE";
  StytchEventType["B2BPasswordAuthenticate"] = "B2B_PASSWORD_AUTHENTICATE";
  StytchEventType["B2BPasswordResetByEmailStart"] = "B2B_PASSWORD_RESET_BY_EMAIL_START";
  StytchEventType["B2BPasswordResetByEmail"] = "B2B_PASSWORD_RESET_BY_EMAIL";
  StytchEventType["B2BPasswordResetBySession"] = "B2B_PASSWORD_RESET_BY_SESSION";
  StytchEventType["B2BSMSOTPSend"] = "B2B_SMS_OTP_SEND";
  StytchEventType["B2BSMSOTPAuthenticate"] = "B2B_SMS_OTP_AUTHENTICATE";
  StytchEventType["B2BTOTPCreate"] = "B2B_TOTP_CREATE";
  StytchEventType["B2BTOTPAuthenticate"] = "B2B_TOTP_AUTHENTICATE";
  StytchEventType["B2BRecoveryCodesRecover"] = "B2B_RECOVERY_CODES_RECOVER";
})(StytchEventType || (StytchEventType = {}));
var RNUIProducts;
(function (RNUIProducts) {
  RNUIProducts[RNUIProducts["emailMagicLinks"] = 0] = "emailMagicLinks";
  RNUIProducts[RNUIProducts["oauth"] = 1] = "oauth";
  RNUIProducts[RNUIProducts["otp"] = 2] = "otp";
  RNUIProducts[RNUIProducts["passwords"] = 3] = "passwords";
})(RNUIProducts || (RNUIProducts = {}));

/**
 * An Error class thrown when the SDK is unable to reach the Stytch servers,
 * or when the Stytch servers return a value the SDK cannot understand.
 * Usually - it means that you're offline!
 */
var SDKAPIUnreachableError = /*#__PURE__*/function (_Error) {
  _inherits(SDKAPIUnreachableError, _Error);
  function SDKAPIUnreachableError(message, details) {
    var _this;
    _classCallCheck(this, SDKAPIUnreachableError);
    _this = _callSuper(this, SDKAPIUnreachableError, [message + '\n' + details]);
    _this.message = message + '\n' + details;
    _this.name = 'SDKAPIUnreachableError';
    _this.details = details;
    Object.setPrototypeOf(_assertThisInitialized(_this), SDKAPIUnreachableError.prototype);
    return _this;
  }
  return _createClass(SDKAPIUnreachableError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input fails client-side validation -
 * for example if a field that was expected to be a number is instead a string.
 */
var StytchSDKUsageError = /*#__PURE__*/function (_Error2) {
  _inherits(StytchSDKUsageError, _Error2);
  function StytchSDKUsageError(methodName, message) {
    var _this2;
    _classCallCheck(this, StytchSDKUsageError);
    _this2 = _callSuper(this, StytchSDKUsageError);
    _this2.name = 'StytchSDKUsageError';
    _this2.message = "Invalid call to ".concat(methodName, "\n") + message;
    return _this2;
  }
  return _createClass(StytchSDKUsageError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input does not adhere to the Stytch API schema -
 * for example if a field that was expected to be a number is instead a string.
 */
var StytchSDKSchemaError = /*#__PURE__*/function (_Error3) {
  _inherits(StytchSDKSchemaError, _Error3);
  function StytchSDKSchemaError(schemaError) {
    var _this3;
    _classCallCheck(this, StytchSDKSchemaError);
    var _a;
    _this3 = _callSuper(this, StytchSDKSchemaError);
    _this3.name = 'StytchSDKSchemaError';
    var messages = (_a = schemaError.body) === null || _a === void 0 ? void 0 : _a.map(function (err) {
      return "".concat(err.dataPath, ": ").concat(err.message);
    }).join('\n');
    _this3.message = "[400] Request does not match expected schema\n".concat(messages);
    return _this3;
  }
  return _createClass(StytchSDKSchemaError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class wrapping a well-formed JSON error from the Stytch API.
 * The Stytch error should match one listed at {@link https://stytch.com/docs/api/errors}
 */
var StytchSDKAPIError = /*#__PURE__*/function (_Error4) {
  _inherits(StytchSDKAPIError, _Error4);
  function StytchSDKAPIError(details) {
    var _this4;
    _classCallCheck(this, StytchSDKAPIError);
    _this4 = _callSuper(this, StytchSDKAPIError);
    _this4.name = 'StytchSDKAPIError';
    var status_code = details.status_code,
      error_type = details.error_type,
      error_message = details.error_message,
      error_url = details.error_url,
      request_id = details.request_id;
    _this4.error_type = error_type;
    _this4.error_message = error_message;
    _this4.error_url = error_url;
    _this4.request_id = request_id;
    _this4.status_code = status_code;
    _this4.message = "[".concat(status_code, "] ").concat(error_type, "\n") + "".concat(error_message, "\n") + "See ".concat(error_url, " for more information.\n") + (
    // Web-Backend doesn't have request IDs yet, so if a request fails there it won't have one.
    // We should figure out how returning tracing info should work
    request_id ? "request_id: ".concat(request_id, "\n") : '');
    return _this4;
  }
  return _createClass(StytchSDKAPIError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * If the SDK throws an error with an error type included in this array, the local session and
 * user state will be cleared locally.
 */
var UNRECOVERABLE_ERROR_TYPES = ['unauthorized_credentials', 'user_unauthenticated', 'invalid_secret_authentication', 'session_not_found'];
/**
 * An Error class representing an error within Stytch.
 */
var StytchError = /*#__PURE__*/function (_Error5) {
  _inherits(StytchError, _Error5);
  function StytchError(name, message) {
    var _this5;
    _classCallCheck(this, StytchError);
    _this5 = _callSuper(this, StytchError, [message]);
    _this5.name = name;
    return _this5;
  }
  return _createClass(StytchError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the SDK is unable to reach the Stytch servers,
 * or when the Stytch servers return a value the SDK cannot understand.
 * Usually - it means that you're offline!
 */
var StytchAPIUnreachableError = /*#__PURE__*/function (_StytchError) {
  _inherits(StytchAPIUnreachableError, _StytchError);
  function StytchAPIUnreachableError(details) {
    var _this6;
    _classCallCheck(this, StytchAPIUnreachableError);
    _this6 = _callSuper(this, StytchAPIUnreachableError, ['StytchAPIUnreachableError', details]);
    Object.setPrototypeOf(_assertThisInitialized(_this6), StytchAPIUnreachableError.prototype);
    return _this6;
  }
  return _createClass(StytchAPIUnreachableError);
}(StytchError);
/**
 * An Error class thrown when the provided input does not adhere to the Stytch API schema -
 * for example if a field that was expected to be a number is instead a string.
 */
var StytchAPISchemaError = /*#__PURE__*/function (_StytchError2) {
  _inherits(StytchAPISchemaError, _StytchError2);
  function StytchAPISchemaError(schemaError) {
    _classCallCheck(this, StytchAPISchemaError);
    var _a;
    var messages = (_a = schemaError.body) === null || _a === void 0 ? void 0 : _a.map(function (err) {
      return "".concat(err.dataPath, ": ").concat(err.message);
    }).join('\n');
    return _callSuper(this, StytchAPISchemaError, ['StytchAPISchemaError', "Request does not match expected schema\n".concat(messages)]);
  }
  return _createClass(StytchAPISchemaError);
}(StytchError);
/**
 * An Error class wrapping a well-formed JSON error from the Stytch API.
 * The Stytch error should match one listed at {@link https://stytch.com/docs/api/errors}
 */
var StytchAPIError = /*#__PURE__*/function (_StytchError3) {
  _inherits(StytchAPIError, _StytchError3);
  function StytchAPIError(details) {
    var _this7;
    _classCallCheck(this, StytchAPIError);
    var status_code = details.status_code,
      error_type = details.error_type,
      error_message = details.error_message,
      error_url = details.error_url,
      request_id = details.request_id;
    _this7 = _callSuper(this, StytchAPIError, ['StytchAPIError', "[".concat(status_code, "] ").concat(error_type, "\n") + "".concat(error_message, "\n") + "See ".concat(error_url, " for more information.\n") + (
    // Web-Backend doesn't have request IDs yet, so if a request fails there it won't have one.
    // We should figure out how returning tracing info should work
    request_id ? "request_id: ".concat(request_id, "\n") : '')]);
    _this7.error_type = error_type;
    _this7.error_message = error_message;
    _this7.error_url = error_url;
    _this7.request_id = request_id;
    _this7.status_code = status_code;
    return _this7;
  }
  return _createClass(StytchAPIError);
}(StytchError);
/**
 * An Error class used in the Stytch SDK.
 */
var StytchSDKError = /*#__PURE__*/function (_StytchError4) {
  _inherits(StytchSDKError, _StytchError4);
  function StytchSDKError(name, description, options) {
    var _this8;
    _classCallCheck(this, StytchSDKError);
    _this8 = _callSuper(this, StytchSDKError, [name, description]);
    _this8.options = options;
    return _this8;
  }
  return _createClass(StytchSDKError);
}(StytchError);
/**
 * Thrown when you attempt to perform an action that requires a session, but no local session exists
 */
var NoCurrentSessionError = /*#__PURE__*/function (_StytchSDKError) {
  _inherits(NoCurrentSessionError, _StytchSDKError);
  function NoCurrentSessionError() {
    _classCallCheck(this, NoCurrentSessionError);
    return _callSuper(this, NoCurrentSessionError, ['NoCurrentSessionError', 'There is no session currently available. Make sure the user is authenticated with a valid session.']);
  }
  return _createClass(NoCurrentSessionError);
}(StytchSDKError);
/**
 * Thrown when an unrecognized error is thrown
 */
var InternalError = /*#__PURE__*/function (_StytchSDKError2) {
  _inherits(InternalError, _StytchSDKError2);
  function InternalError(message) {
    _classCallCheck(this, InternalError);
    return _callSuper(this, InternalError, ['InternalError', message ? message : 'An internal error has occurred. Please contact Stytch if this occurs.']);
  }
  return _createClass(InternalError);
}(StytchSDKError);
/**
 * Thrown when no biometric registration exists
 */
var NoBiometricsRegistrationError = /*#__PURE__*/function (_StytchSDKError3) {
  _inherits(NoBiometricsRegistrationError, _StytchSDKError3);
  function NoBiometricsRegistrationError() {
    _classCallCheck(this, NoBiometricsRegistrationError);
    return _callSuper(this, NoBiometricsRegistrationError, ['NoBiometricsRegistrationError', 'There is no biometric registration available. Authenticate with another method and add a new biometric registration first.']);
  }
  return _createClass(NoBiometricsRegistrationError);
}(StytchSDKError);
/**
 * Thrown when biometrics are unavailable on the device
 */
var BiometricsUnavailableError = /*#__PURE__*/function (_StytchSDKError4) {
  _inherits(BiometricsUnavailableError, _StytchSDKError4);
  function BiometricsUnavailableError() {
    _classCallCheck(this, BiometricsUnavailableError);
    return _callSuper(this, BiometricsUnavailableError, ['BiometricsUnavailableError', 'Biometrics is not available on the device.']);
  }
  return _createClass(BiometricsUnavailableError);
}(StytchSDKError);
/**
 * Thrown when the biometrics enrollment has changed, and the underlying key is no longer usable
 */
var KeyInvalidatedError = /*#__PURE__*/function (_StytchSDKError5) {
  _inherits(KeyInvalidatedError, _StytchSDKError5);
  function KeyInvalidatedError() {
    _classCallCheck(this, KeyInvalidatedError);
    return _callSuper(this, KeyInvalidatedError, ['KeyInvalidatedError', 'The biometrics enrollment on the device has changed.']);
  }
  return _createClass(KeyInvalidatedError);
}(StytchSDKError);
/**
 * Thrown when the Keystore is determined to be unavailable
 */
var KeystoreUnavailableError = /*#__PURE__*/function (_StytchSDKError6) {
  _inherits(KeystoreUnavailableError, _StytchSDKError6);
  function KeystoreUnavailableError() {
    _classCallCheck(this, KeystoreUnavailableError);
    return _callSuper(this, KeystoreUnavailableError, ['KeystoreUnavailableError', 'The Android keystore is unavailable on the device. Consider setting allowFallbackToCleartext to true.']);
  }
  return _createClass(KeystoreUnavailableError);
}(StytchSDKError);
/**
 * Thrown when there is no biometric factor enrolled on device
 */
var NoBiometricsEnrolledError = /*#__PURE__*/function (_StytchSDKError7) {
  _inherits(NoBiometricsEnrolledError, _StytchSDKError7);
  function NoBiometricsEnrolledError() {
    _classCallCheck(this, NoBiometricsEnrolledError);
    return _callSuper(this, NoBiometricsEnrolledError, ['NoBiometricsEnrolledError', 'There is no biometric factor enrolled on the device. Add a biometric factor in the device settings.']);
  }
  return _createClass(NoBiometricsEnrolledError);
}(StytchSDKError);
/**
 * Thrown when the user has cancelled the prompt
 */
var UserCancellationError = /*#__PURE__*/function (_StytchSDKError8) {
  _inherits(UserCancellationError, _StytchSDKError8);
  function UserCancellationError() {
    _classCallCheck(this, UserCancellationError);
    return _callSuper(this, UserCancellationError, ['UserCancellationError', 'The user canceled the prompt. Ask the user to try again.']);
  }
  return _createClass(UserCancellationError);
}(StytchSDKError);
/**
 * Thrown when the user has been locked out of biometrics
 */
var UserLockedOutError = /*#__PURE__*/function (_StytchSDKError9) {
  _inherits(UserLockedOutError, _StytchSDKError9);
  function UserLockedOutError() {
    _classCallCheck(this, UserLockedOutError);
    return _callSuper(this, UserLockedOutError, ['UserLockedOutError', 'The user has been locked out due to too many failed attempts. Ask the user to try again later.']);
  }
  return _createClass(UserLockedOutError);
}(StytchSDKError);
/**
 * Thrown when biometrics register/authenticate calls are made with mismatched `allowDeviceCredentials` parameter
 */
var DeviceCredentialsNotAllowedError = /*#__PURE__*/function (_StytchSDKError10) {
  _inherits(DeviceCredentialsNotAllowedError, _StytchSDKError10);
  function DeviceCredentialsNotAllowedError() {
    _classCallCheck(this, DeviceCredentialsNotAllowedError);
    return _callSuper(this, DeviceCredentialsNotAllowedError, ['DeviceCredentialsNotAllowedError', 'The device credentials allowment is mismatched. Change the allowDeviceCredentials parameter to be the same in both the register and authenticate methods.']);
  }
  return _createClass(DeviceCredentialsNotAllowedError);
}(StytchSDKError);
/**
 * Thrown when no Google client ID is found for the project
 */
var MissingGoogleClientIDError = /*#__PURE__*/function (_StytchSDKError11) {
  _inherits(MissingGoogleClientIDError, _StytchSDKError11);
  function MissingGoogleClientIDError() {
    _classCallCheck(this, MissingGoogleClientIDError);
    return _callSuper(this, MissingGoogleClientIDError, ['MissingGoogleClientIDError', 'No Google client ID was found in the project.']);
  }
  return _createClass(MissingGoogleClientIDError);
}(StytchSDKError);
/**
 * Thrown when there was an error generating or retrieving a PKCE keypair
 */
var MissingPKCEError = /*#__PURE__*/function (_StytchSDKError12) {
  _inherits(MissingPKCEError, _StytchSDKError12);
  function MissingPKCEError() {
    _classCallCheck(this, MissingPKCEError);
    return _callSuper(this, MissingPKCEError, ['MissingPKCEError', 'Make sure this flow is completed on the same device on which it was started.']);
  }
  return _createClass(MissingPKCEError);
}(StytchSDKError);
/**
 * Thrown when a native OAuth flow is missing the id_token
 */
var MissingAuthorizationCredentialIDTokenError = /*#__PURE__*/function (_StytchSDKError13) {
  _inherits(MissingAuthorizationCredentialIDTokenError, _StytchSDKError13);
  function MissingAuthorizationCredentialIDTokenError() {
    _classCallCheck(this, MissingAuthorizationCredentialIDTokenError);
    return _callSuper(this, MissingAuthorizationCredentialIDTokenError, ['MissingAuthorizationCredentialIDTokenError', 'The authorization credential is missing an ID token.']);
  }
  return _createClass(MissingAuthorizationCredentialIDTokenError);
}(StytchSDKError);
/**
 * Thrown when a native OAuth flow returns an invalid credential
 */
var InvalidAuthorizationCredentialError = /*#__PURE__*/function (_StytchSDKError14) {
  _inherits(InvalidAuthorizationCredentialError, _StytchSDKError14);
  function InvalidAuthorizationCredentialError() {
    _classCallCheck(this, InvalidAuthorizationCredentialError);
    return _callSuper(this, InvalidAuthorizationCredentialError, ['InvalidAuthorizationCredentialError', 'The authorization credential is invalid. Verify that OAuth is set up correctly in the developer console, and call the start flow method.']);
  }
  return _createClass(InvalidAuthorizationCredentialError);
}(StytchSDKError);
/**
 * Thrown when a Google OneTap flow is not completed successfully
 */
var NoCredentialsPresentError = /*#__PURE__*/function (_StytchSDKError15) {
  _inherits(NoCredentialsPresentError, _StytchSDKError15);
  function NoCredentialsPresentError() {
    _classCallCheck(this, NoCredentialsPresentError);
    return _callSuper(this, NoCredentialsPresentError, ['NoCredentialsPresentError', 'The user did not provide credentials for a Google OneTap attempt']);
  }
  return _createClass(NoCredentialsPresentError);
}(StytchSDKError);
/**
 * Thrown when a public key was not found
 */
var MissingPublicKeyError = /*#__PURE__*/function (_StytchSDKError16) {
  _inherits(MissingPublicKeyError, _StytchSDKError16);
  function MissingPublicKeyError() {
    _classCallCheck(this, MissingPublicKeyError);
    return _callSuper(this, MissingPublicKeyError, ['MissingPublicKeyError', 'Failed to retrieve the public key. Add a new biometric registration.']);
  }
  return _createClass(MissingPublicKeyError);
}(StytchSDKError);
/**
 * Thrown when the challenge string failed to be signed
 */
var ChallengeSigningFailedError = /*#__PURE__*/function (_StytchSDKError17) {
  _inherits(ChallengeSigningFailedError, _StytchSDKError17);
  function ChallengeSigningFailedError() {
    _classCallCheck(this, ChallengeSigningFailedError);
    return _callSuper(this, ChallengeSigningFailedError, ['ChallengeSigningFailedError', 'Failed to sign the challenge with the key.']);
  }
  return _createClass(ChallengeSigningFailedError);
}(StytchSDKError);
/**
 * Thrown when the SDK has not been configured
 */
var SDKNotConfiguredError = /*#__PURE__*/function (_StytchSDKError18) {
  _inherits(SDKNotConfiguredError, _StytchSDKError18);
  function SDKNotConfiguredError() {
    _classCallCheck(this, SDKNotConfiguredError);
    return _callSuper(this, SDKNotConfiguredError, ['SDKNotConfiguredError', 'Stytch client is not confiured. You must call the configure method before using the SDK']);
  }
  return _createClass(SDKNotConfiguredError);
}(StytchSDKError);
/**
 * Thrown when the code challenge failed to be generated
 */
var FailedCodeChallengeError = /*#__PURE__*/function (_StytchSDKError19) {
  _inherits(FailedCodeChallengeError, _StytchSDKError19);
  function FailedCodeChallengeError() {
    _classCallCheck(this, FailedCodeChallengeError);
    return _callSuper(this, FailedCodeChallengeError, ['FailedCodeChallengeError', 'Failed to create a code challenge']);
  }
  return _createClass(FailedCodeChallengeError);
}(StytchSDKError);
/**
 * Thrown when Passkeys are unsupported on a device
 */
var PasskeysUnsupportedError = /*#__PURE__*/function (_StytchSDKError20) {
  _inherits(PasskeysUnsupportedError, _StytchSDKError20);
  function PasskeysUnsupportedError() {
    _classCallCheck(this, PasskeysUnsupportedError);
    return _callSuper(this, PasskeysUnsupportedError, ['PasskeysUnsupportedError', 'Passkeys are not supported on this device']);
  }
  return _createClass(PasskeysUnsupportedError);
}(StytchSDKError);
/**
 * Thrown when user data failed to be decrypted
 */
var FailedToDecryptDataError = /*#__PURE__*/function (_StytchSDKError21) {
  _inherits(FailedToDecryptDataError, _StytchSDKError21);
  function FailedToDecryptDataError() {
    _classCallCheck(this, FailedToDecryptDataError);
    return _callSuper(this, FailedToDecryptDataError, ['FailedToDecryptDataError', 'Failed to decrypt user data']);
  }
  return _createClass(FailedToDecryptDataError);
}(StytchSDKError);
/**
 * Thrown when Biometrics failed
 */
var BiometricsFailedError = /*#__PURE__*/function (_StytchSDKError22) {
  _inherits(BiometricsFailedError, _StytchSDKError22);
  function BiometricsFailedError() {
    _classCallCheck(this, BiometricsFailedError);
    return _callSuper(this, BiometricsFailedError, ['BiometricsFailedError', 'Biometric authentication failed']);
  }
  return _createClass(BiometricsFailedError);
}(StytchSDKError);
/**
 * Thrown when a start URL was invalid
 */
var InvalidStartUrlError = /*#__PURE__*/function (_StytchSDKError23) {
  _inherits(InvalidStartUrlError, _StytchSDKError23);
  function InvalidStartUrlError() {
    _classCallCheck(this, InvalidStartUrlError);
    return _callSuper(this, InvalidStartUrlError, ['InvalidStartUrlError', 'The start URL was invalid or improperly formatted.']);
  }
  return _createClass(InvalidStartUrlError);
}(StytchSDKError);
/**
 * Thrown when a redirect url was invalid
 */
var InvalidRedirectSchemeError = /*#__PURE__*/function (_StytchSDKError24) {
  _inherits(InvalidRedirectSchemeError, _StytchSDKError24);
  function InvalidRedirectSchemeError() {
    _classCallCheck(this, InvalidRedirectSchemeError);
    return _callSuper(this, InvalidRedirectSchemeError, ['InvalidRedirectSchemeError', 'The scheme from the given redirect urls was invalid. Possible reasons include: nil scheme, non-custom scheme (using http or https), or differing schemes for login/signup urls.']);
  }
  return _createClass(InvalidRedirectSchemeError);
}(StytchSDKError);
/**
 * Thrown when the underlying web authentication service failed to return a URL.
 */
var MissingUrlError = /*#__PURE__*/function (_StytchSDKError25) {
  _inherits(MissingUrlError, _StytchSDKError25);
  function MissingUrlError() {
    _classCallCheck(this, MissingUrlError);
    return _callSuper(this, MissingUrlError, ['MissingUrlError', 'The underlying web authentication service failed to return a URL.']);
  }
  return _createClass(MissingUrlError);
}(StytchSDKError);
/**
 * Thrown when the public key credential type was not of the expected type.
 */
var InvalidCredentialTypeError = /*#__PURE__*/function (_StytchSDKError26) {
  _inherits(InvalidCredentialTypeError, _StytchSDKError26);
  function InvalidCredentialTypeError() {
    _classCallCheck(this, InvalidCredentialTypeError);
    return _callSuper(this, InvalidCredentialTypeError, ['InvalidCredentialTypeError', 'The public key credential type was not of the expected type.']);
  }
  return _createClass(InvalidCredentialTypeError);
}(StytchSDKError);
/**
 * Thrown when the public key credential is missing the attestation object
 */
var MissingAttestationObjectError = /*#__PURE__*/function (_StytchSDKError27) {
  _inherits(MissingAttestationObjectError, _StytchSDKError27);
  function MissingAttestationObjectError() {
    _classCallCheck(this, MissingAttestationObjectError);
    return _callSuper(this, MissingAttestationObjectError, ['MissingAttestationObjectError', 'The public key credential is missing the attestation object.']);
  }
  return _createClass(MissingAttestationObjectError);
}(StytchSDKError);
/**
 * Thrown when we received JSON data that could not be converted to a string
 */
var JSONDataNotConvertibleToStringError = /*#__PURE__*/function (_StytchSDKError28) {
  _inherits(JSONDataNotConvertibleToStringError, _StytchSDKError28);
  function JSONDataNotConvertibleToStringError() {
    _classCallCheck(this, JSONDataNotConvertibleToStringError);
    return _callSuper(this, JSONDataNotConvertibleToStringError, ['JSONDataNotConvertibleToStringError', 'JSON data unable to be converted to String type.']);
  }
  return _createClass(JSONDataNotConvertibleToStringError);
}(StytchSDKError);
/**
 * Thrown when RNG fails
 */
var RandomNumberGenerationFailed = /*#__PURE__*/function (_StytchSDKError29) {
  _inherits(RandomNumberGenerationFailed, _StytchSDKError29);
  function RandomNumberGenerationFailed() {
    _classCallCheck(this, RandomNumberGenerationFailed);
    return _callSuper(this, RandomNumberGenerationFailed, ['RandomNumberGenerationFailed', 'Random number generation failed']);
  }
  return _createClass(RandomNumberGenerationFailed);
}(StytchSDKError);
/**
 * Thrown when there was an invalid encoding used for a Passkeys request
 */
var PasskeysInvalidEncoding = /*#__PURE__*/function (_StytchSDKError30) {
  _inherits(PasskeysInvalidEncoding, _StytchSDKError30);
  function PasskeysInvalidEncoding() {
    _classCallCheck(this, PasskeysInvalidEncoding);
    return _callSuper(this, PasskeysInvalidEncoding, ['PasskeysInvalidEncoding', 'Invalid passkey encoding']);
  }
  return _createClass(PasskeysInvalidEncoding);
}(StytchSDKError);
/**
 * Thrown when Passkeys support is misconfigured
 */
var PasskeysMisconfigured = /*#__PURE__*/function (_StytchSDKError31) {
  _inherits(PasskeysMisconfigured, _StytchSDKError31);
  function PasskeysMisconfigured() {
    _classCallCheck(this, PasskeysMisconfigured);
    return _callSuper(this, PasskeysMisconfigured, ['PasskeysMisconfigured', 'Passkeys are misconfigured. Verify that you have added the correct associated domain for your application, and that the signing information is correct.']);
  }
  return _createClass(PasskeysMisconfigured);
}(StytchSDKError);
/**
 * Thrown when there was an invalid encoding used for a Passkeys request
 */
var SignInWithAppleMisconfigured = /*#__PURE__*/function (_StytchSDKError32) {
  _inherits(SignInWithAppleMisconfigured, _StytchSDKError32);
  function SignInWithAppleMisconfigured() {
    _classCallCheck(this, SignInWithAppleMisconfigured);
    return _callSuper(this, SignInWithAppleMisconfigured, ['SignInWithAppleMisconfigured', 'Sign In With Apple is misconfigured. Verify that you have correctly configured Apple OAuth in the Stytch Dashboard and added the Sign In With Apple capability to your project.']);
  }
  return _createClass(SignInWithAppleMisconfigured);
}(StytchSDKError);
function errorToStytchError(error) {
  switch (error.message) {
    case 'internal_error':
      return new InternalError(error.message);
    case 'no_current_session':
      return new NoCurrentSessionError();
    case 'no_biometrics_registration':
      return new NoBiometricsRegistrationError();
    case 'biometrics_unavailable':
      return new BiometricsUnavailableError();
    case 'key_invalidated':
      return new KeyInvalidatedError();
    case 'device_hardware_error':
      return new BiometricsUnavailableError();
    case 'biometrics_not_available':
      return new BiometricsUnavailableError();
    case 'no_biometrics_enrolled':
      return new NoBiometricsEnrolledError();
    case 'keystore_unavailable':
      return new KeystoreUnavailableError();
    case 'no_biometric_key':
      return new KeyInvalidatedError();
    case 'device_credentials_not_allowed':
      return new DeviceCredentialsNotAllowedError();
    case 'user_cancellation':
      return new UserCancellationError();
    case 'user_locked_out':
      return new UserLockedOutError();
    case 'google_onetap_missing_id_token':
      return new MissingAuthorizationCredentialIDTokenError();
    case 'google_onetap_missing_member':
      return new InvalidAuthorizationCredentialError();
    case 'oauth_apple_missing_id_token':
      return new MissingAuthorizationCredentialIDTokenError();
    case 'oauth_apple_credential_invalid':
      return new InvalidAuthorizationCredentialError();
    case 'missing_public_key':
      return new MissingPublicKeyError();
    case 'challenge_signing_failed':
      return new ChallengeSigningFailedError();
    case 'missing_authorization_credential_id_token':
      return new MissingAuthorizationCredentialIDTokenError();
    case 'invalid_authorization_credential':
      return new InvalidAuthorizationCredentialError();
    case 'no_credentials_present':
      return new NoCredentialsPresentError();
    case 'sdk_not_configured':
      return new SDKNotConfiguredError();
    case 'failed_code_challenge':
      return new FailedCodeChallengeError();
    case 'passkeys_unsupported':
      return new PasskeysUnsupportedError();
    case 'failed_to_decrypt_data':
      return new FailedToDecryptDataError();
    case 'biometrics_failed':
      return new BiometricsFailedError();
    case 'invalid_start_url':
      return new InvalidStartUrlError();
    case 'invalid_redirect_scheme':
      return new InvalidRedirectSchemeError();
    case 'missing_url':
      return new MissingUrlError();
    case 'invalid_credential_type':
      return new InvalidCredentialTypeError();
    case 'missing_attestation_object':
      return new MissingAttestationObjectError();
    case 'json_data_not_convertible_to_string':
      return new JSONDataNotConvertibleToStringError();
    case 'random_number_generation_failed':
      return new RandomNumberGenerationFailed();
    case 'passkeys_invalid_encoding':
      return new PasskeysInvalidEncoding();
    case 'passkeys_misconfigured':
      return new PasskeysMisconfigured();
    case 'signinwithapple_misconfigured':
      return new SignInWithAppleMisconfigured();
    default:
      return new StytchSDKError(error.name, error.message);
  }
}

/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `sso`, `passwords`, and `oauth`.
 */
var B2BProducts;
(function (B2BProducts) {
  B2BProducts["emailMagicLinks"] = "emailMagicLinks";
  B2BProducts["sso"] = "sso";
  B2BProducts["passwords"] = "passwords";
  B2BProducts["oauth"] = "oauth";
})(B2BProducts || (B2BProducts = {}));
var AuthFlowType;
(function (AuthFlowType) {
  AuthFlowType["Discovery"] = "Discovery";
  AuthFlowType["Organization"] = "Organization";
  AuthFlowType["PasswordReset"] = "PasswordReset";
})(AuthFlowType || (AuthFlowType = {}));
var B2BMFAProducts;
(function (B2BMFAProducts) {
  B2BMFAProducts["smsOtp"] = "smsOtp";
  B2BMFAProducts["totp"] = "totp";
})(B2BMFAProducts || (B2BMFAProducts = {}));
/**
 * The OAuth providers we support in our B2B OAuth product.
 * Currently we support `google`, and `microsoft`.
 */
var B2BOAuthProviders;
(function (B2BOAuthProviders) {
  B2BOAuthProviders["Google"] = "google";
  B2BOAuthProviders["Microsoft"] = "microsoft";
})(B2BOAuthProviders || (B2BOAuthProviders = {}));
export { B2BMFAProducts as $, InvalidStartUrlError as A, B2BOAuthProviders as B, ChallengeSigningFailedError as C, DeviceCredentialsNotAllowedError as D, InvalidRedirectSchemeError as E, FailedCodeChallengeError as F, MissingUrlError as G, InvalidCredentialTypeError as H, InternalError as I, MissingAttestationObjectError as J, KeyInvalidatedError as K, JSONDataNotConvertibleToStringError as L, MissingGoogleClientIDError as M, NoCurrentSessionError as N, OTPMethods as O, Products as P, RandomNumberGenerationFailed as Q, RNUIProducts as R, StytchAPIUnreachableError as S, PasskeysInvalidEncoding as T, UNRECOVERABLE_ERROR_TYPES as U, PasskeysMisconfigured as V, Wallets as W, SignInWithAppleMisconfigured as X, errorToStytchError as Y, B2BProducts as Z, AuthFlowType as _, StytchAPISchemaError as a, StytchAPIError as b, StytchSDKUsageError as c, StytchSDKAPIError as d, StytchSDKSchemaError as e, SDKAPIUnreachableError as f, OAuthProviders as g, OneTapPositions as h, StytchEventType as i, StytchError as j, StytchSDKError as k, NoBiometricsRegistrationError as l, BiometricsUnavailableError as m, KeystoreUnavailableError as n, NoBiometricsEnrolledError as o, UserCancellationError as p, UserLockedOutError as q, MissingPKCEError as r, MissingAuthorizationCredentialIDTokenError as s, InvalidAuthorizationCredentialError as t, NoCredentialsPresentError as u, MissingPublicKeyError as v, SDKNotConfiguredError as w, PasskeysUnsupportedError as x, FailedToDecryptDataError as y, BiometricsFailedError as z };
